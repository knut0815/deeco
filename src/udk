
#  FILENAME:    udk
#  VERSION:     (refer to date or ident)
#  DATE:        01-Sep-2005  (remember to update)
#  PROJECT:     deeco
#  SYSTEM:      SCO UnixWare 7.1.1 / i386  (SVR5 based)
#  COMPILER:    SCO UDK CC  (Edison Design Group C++ front end)
#  MAKE:        SCO UDK make
#  STATUS:      appears stable

#  $Date: 2005/11/25 17:05:28 $
#  $Author: morrison $
#  $Revision: 1.1 $
#  $RCSfile: udk,v $

#   ------------------
#   Command-line usage
#   ------------------

     # make -f <makefile>          build deeco from source
     # make -f <makefile> clean    delete files generated by make
     # make -f <makefile> tidy     delete files generated by make except target
     # make -f <makefile> comment  adds text comments to the binary

#   ---------------------------
#   User-modifiable definitions
#   ---------------------------
#
#   Note that -dn binaries will run on Linux/i386 as well as
#   on UnixWare 2/7.

RELEASE  =   006

TARGET   =   deeco$(RELEASE)

CCFLAGS  =   -dn -O
#CCFLAGS  =   -g

     # -v  is verbose (remarks also reported)
     # -dn is static link libraries (.so) (to avoid run-time dependencies)
     # -g  is debug information
     # -O  is optimization, overrides -g
     # -#  is display each command line just prior to use

#   --------------
#   Platform flags
#   --------------
#
#   Enable the second line for SCO UnixWare 7.1.1 UDK.  The first
#   line applies to SCO UnixWare 2.1.2 SDK.  The current code-base
#   will also compile on SDK, at least in its form at the time of
#   writing.

#PLFLAGS  =   -Xo
#PLFLAGS  =   -Wf,--cfront_3.0 -DNAMESPACED_SC -DDISABLE_UNCEX_FN
PLFLAGS  =   -DNAMESPACED_SC

     # Development environment options
     #
     # -Xo is use cfront 3.0 language dialect
     # -Wf, is used to pass arguments to the EDG C++ front end phase
     #   --cfront_3.0 gives cfront compatability, whilst still allowing namespaces
     #
     # deeco-specific directives
     #
     # -DNAMESPACED_SC enables "using namespace SCO_SC" in source code
     # -DDISABLE_UNCEX_FN disables system fn "bool std::uncaught_execption()"
     #
     # Refer to [General notes] for details on system header modifications.

#   -----------------
#   Compiler identity
#   -----------------

CC      =   CC

     # CC is the system C++ compiler (see intro for details)

#   -------------
#   Include files
#   -------------

INCL    =   #

#   ----------------
#   Static libraries
#   ----------------

LIBS    =  -lm -l++

     # libm.a    is the maths archive
     # lib++.a   contains whole USL SC suite, libGraph.a and libGA.a not present
     # libfs.a   is not used
     # libglpk.a is the GLPK archive

#   ------------
#   deeco target
#   ------------

OBJECTS       = App.o Balan.o Collect.o Connect.o Convers.o Data.o deeco.o\
                deecoApp.o Demand.o DGraph.o Net.o Network.o Port.o Proc.o\
                ProcType.o Scen.o Simplex.o Storage.o
$(TARGET)     : $(OBJECTS)
		$(CC) $(PLFLAGS) $(CCFLAGS) $(INCL) $(OBJECTS) $(LIBS) -o $(TARGET)

#   -------------
#   deeco objects
#   -------------

AppHEADS      = TestFlag.h
App.o         : $(AppHEADS) App.h App.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) App.C

BalanHEADS    = App.h Data.h TestFlag.h
Balan.o       : $(BalanHEADS) Balan.h Balan.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Balan.C

ConversHEADS  = App.h Data.h DGraph.h Proc.h
Convers.o     : $(ConversHEADS) Convers.h Convers.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Convers.C

CollectHEADS  = App.h Data.h DGraph.h Proc.h
Collect.o     : $(CollectHEADS) Collect.h Collect.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Collect.C

ConnectHEADS  = App.h Data.h TestFlag.h
Connect.o     : $(ConnectHEADS) Connect.h Connect.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Connect.C

DataHEADS     = App.h TestFlag.h
Data.o        : $(DataHEADS) Data.h Data.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Data.C

DGraphHEADS   = Data.h
DGraph.o      : $(DGraphHEADS) DGraph.h DGraph.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) DGraph.C

deecoHEADS    = App.h Balan.h Connect.h Data.h deecoApp.h DGraph.h Net.h\
                Proc.h ProcType.h Scen.h Simplex.h TestFlag.h except.h\
                version.h
deeco.o       : $(deecoHEADS) deeco.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) deeco.C

deecoAppHEADS = App.h Balan.h Connect.h Data.h DGraph.h Net.h Proc.h\
                ProcType.h Scen.h Simplex.h TestFlag.h
deecoApp.o    : $(deecoAppHEADS) deecoApp.h  deecoApp.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) deecoApp.C

DemandHEADS   = App.h Data.h DGraph.h Proc.h
Demand.o      : $(DemandHEADS) Demand.h Demand.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Demand.C

NetHEADS      = App.h Balan.h Connect.h Data.h DGraph.h Proc.h ProcType.h\
                Simplex.h TestFlag.h
Net.o         : $(NetHEADS) Net.h Net.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Net.C

NetworkHEADS  = App.h Data.h DGraph.h Proc.h
Network.o     : $(NetworkHEADS) Network.h Network.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Network.C

PortHEADS     = App.h Data.h DGraph.h Proc.h
Port.o        : $(PortHEADS) Port.h Port.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Port.C

ProcHEADS     = App.h Data.h TestFlag.h
Proc.o        : $(ProcHEADS) Proc.h Proc.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Proc.C

ProcTypeHEADS = App.h Data.h
ProcType.o    : $(ProcTypeHEADS) ProcType.h ProcType.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) ProcType.C

ScenHEADS     = App.h Balan.h Data.h Connect.h Proc.h TestFlag.h
Scen.o        : $(ScenHEADS) Scen.h Scen.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Scen.C

SimplexHEADS  = nr.h nrutil.h nrutil.c simplx.c simp1.c simp2.c simp3.c\
                TestFlag.h
Simplex.o     : $(SimplexHEADS) Simplex.h Simplex.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Simplex.C

StorageHEADS  = App.h Data.h DGraph.h Proc.h
Storage.o     : $(StorageHEADS) Storage.h Storage.C
		$(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) Storage.C

#   ------------------
#   Make clean or tidy
#   ------------------

.PHONY      : tidy
tidy        :
		-rm $(OBJECTS) $(OBJECTS:.o=.ii) $(OBJECTS:.o=.ti) > /dev/null 2>&1

.PHONY      : clean
clean       :
		-rm $(TARGET) $(OBJECTS) $(OBJECTS:.o=.ii) $(OBJECTS:.o=.ti) > /dev/null 2>&1

#   The .PHONY syntax protects agains certain file naming clashes.

#   ------------------
#   Append comments
#   ------------------

.PHONY      : comment
comment     : # no dependencies
		mcs -a " "                      $(TARGET)
		mcs -a " Date    = `date`"      $(TARGET)
		mcs -a " Host    = ${HOSTNAME}" $(TARGET)
		mcs -a " User    = ${USER}"     $(TARGET)
		mcs -a " RELEASE = $(RELEASE)"  $(TARGET)
		mcs -a " TARGET  = $(TARGET)"   $(TARGET)
		mcs -a " CC      = $(CC)"       $(TARGET)
		mcs -a " PLFLAGS = $(PLFLAGS)"  $(TARGET)
		mcs -a " CCFLAGS = $(CCFLAGS)"  $(TARGET)
		mcs -a " INCL    = $(INCL)"     $(TARGET)
		mcs -a " LIBS    = $(LIBS)"     $(TARGET)
		mcs -p $(TARGET)

#    This feature is not widely documented.  MCS is manipulate comment section.
#    Run this command directly after making a new binary.  To view the comments
#    use: $ mcs -p binary-name.

#   ================================================================================

#   -------------
#   General notes
#   -------------
#
#   System make
#
#   * Trailing spaces _may_ be significant (unlike GNU make)
#
#   Hewlett-Packard HP-UX 8.07 CC
#
#   * For debugging, Thomas recommends to first compile without -g flag, then
#     delete deeco *.o files, and then recompile with -g flag - this prevents
#     one from ending up in template source-code whilst debugging.
#
#   SCO UnixWare 2.1.2 SDK
#
#   * The above procedure may not be necessary for the SDK environment as the
#     C++ Standard Components are pre-compiled.
#
#   * The required porting modifications are too numerous to list here.
#
#   SCO UnixWare 7.1.1 UDK
#
#   The following source and system file modifications were required:
#
#   * The system header "/usr/include/sys/file.h", line 105 was modified to
#     suppress a trivial warning regarding a nested comment.
#
#   * The system header "/user/include/CC/exception", line 40 was disabled
#     via an "#ifndef DISABLE_UNCEX_FN" block to remove system function
#     "bool std::uncaught_execption()" from view of the compilation sytem.
#     This is not subtle.  However it is it is difficult to imagine a call
#     to this function in the context of a sensibly executing program.
#     (Note: -Wf,--bool does not extend to the prelink phase.)
#
#   * The deeco header "App.h", starting line 33 now contains a "using
#     namespace SCO_SC" statement, which is in an "#ifdef NAMESPACED_SC"
#     to allow compilation control from the deeco makefile.  This was not
#     notated using the operating system name because there is a possiblity
#     that SDK might be backloaded onto UW7.

#   ---------------------
#   deeco makefile syntax
#   ---------------------
#
#   OBJECTS =      file1.o file2.o
#   $(TARGET) :    $(OBJECTS)
#   [tab]          $(CC) $(PLFLAGS) $(CCFLAGS) $(INCL) $(OBJECTS) $(LIBS) -o $(TARGET)
#
#   fileHEADS =    head1.h head2.h                                # macro definition
#   file.o :       $(fileHEADS) file.h file.C                     # dependency line
#   [tab]          $(CC) $(PLFLAGS) -c $(CCFLAGS) $(INCL) file.C  # shell command one
#   [tab]          more commands                                  # shell command two
#
#   Notes
#   1.  dependency line syntax:   target(s) : prerequisite(s) (can be null)
#       means subsequent command executed if the prerequisites are met
#   2.  shell commands preceded by [tab] on next line(s)
#   3.  escaped newline (\[Enter]) for line-wraps - macro definitions, shell
#       commands and comments
#   4.  shell command preceded by hyphen (-) means ignore any error returned
#
#   Rules
#   Updates a target only if its dependencies are newer than that target.
#   All prerequisite files of a target are added recursively to the list of
#   targets.  Missing targets are automatically rebuilt.
#
#   Dependency List
#   The "fileHEADS = " header-dependency list should contain all potentially
#   modifiable - that is, local - header files relating to the object file in
#   question, but excluding <filename.h> (accounted for directly on the following
#   dependency line). Therefore, the header-dependency list should comprise all:
#
#               #include "headername.h"
#
#   references within <filename.C> and <filename.h>. In addition, the header-
#   dependency list should also contain all downstream local header-dependencies
#   arising from the initial inventory, and so on - although the need for multiple
#   depth header calls should be questioned.

#   -------------
#   make synopsis
#   -------------
#
#   make [-f makefile] [flags] [target]
#
#   target = <filename.o> for specific object files
#   otherwise deeco executable is built
#
#  -i   ignore invoked command error codes (alternatively, precede problematic
#       commands with a hyphen, see note 4 above)
#  -k   abandon work on current entry if it fails, but continue on other branches
#       that do not depend on that entry
#  -n   no execute mode - print commands instead (used for testing)
#  -p   print complete set of macro definitions, suffices, and target descriptions
#  -q   question - gives information as to whether target has been updated or not
#  -t   touch the target files - update their modified-on date - without executing
#       any commands
#  -u   unconditionally make target, ignoring all timestamps

#   -----------------
#   Compiler switches
#   -----------------
#
#   Based on the CC man page from SCO UnixWare 2.1.2 SDK
#
#  -c       suppresses linking phase, .o files produced are not removed
#  -E       sends preprocessing result to standard output (for testing)
#  -f       causes extra code that instruments the program to capture free store
#           usage information, for use with fs(3C++) tool (requires -lfs?)
#  -g       cause the generation of information that facilitates symbolic debugging
#  -H       causes the preprocessor to print the pathnames of all included files to
#           standard error
#  -I dir   search path for included files before searching INDCIR/CC and INDCIR,
#           in that order (abridged)
#  -Kno_ieee     overrides ieee default, does not produce NaN and Inf (abridged)
#  -Kno_inline   overrides c++_inline default for efficiency (abridged)
#  -l str   causes linking phase to search library libstr.so or libstr.a (abridged)
#  -O       optimization switch
#  -P       similar to -E, but output can be further processed (abridged)
#  -q str   causes extra code that instruments the program for profiling (abridged):
#             l   for lprof
#             f   for fprof
#  -T list  controls the instantiation of templates - the default automatic
#           instantiation is recommended (abridged)
#  -V       CC and each tool prints out version information to standard error
#  -v       causes compiler to issue remarks, and prelinker to issue information
#           about template instantiation (abridged)
#  -w       causes compiler to suppress warnings
#  -X str   controls the language dialect in use (abridged):
#             d   default - essentially the ARM - see man_CC - Standards Compliance
#             w   strict ANSI/ISO conformance, also gives warnings
#             e   same as w but with errors not warnings
#             o   cfront mode - uses cfront Language System and anachronisms
#             t   for cc, not CC
#  -Z       byte alignment behavior (abridged)
#  -#       prints each tool and its options and arguments to standard error just
#           before it is invoked ('recognized' switch)

#  $Source: /home/morrison/milp-mid-2005/deeco.006.2/RCS/udk,v $
#  FILE END

